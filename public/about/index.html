<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Don的小窝 | 关于</title>
    <meta name="description" content="任东卫 手机号 : 15063080813 邮箱 : 86930007@qq.com github : http://github.com/rendongwei gitee : don. (rendongwei) - Gitee.com 工作年限 : 11年 教育背景 2009-2011 青岛职业技术学院 计算机应用技术 专 ">
    <link rel="canonical" href="http://rendongwei.cn/about/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="关于" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://rendongwei.cn/about/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="关于"/>
<meta name="twitter:description" content=""/>

    
        
    
    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>


    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/yes.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">Don的小窝</span>
            </a>
        </div>
        <div class="navbar-menu">
            
            <a href="/">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                    </div>
                </div>
            </a>
            
            <a href="/posts">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                    </div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                    </div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                    </div>
                </div>
            </a>
            
            <a href="/about">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                    </div>
                </div>
            </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            
            <div class="mode">
                <span class="sun"><i class="fa fa-sun-o"></i></span>
                <span class="moon"><i class="fa fa-moon-o"></i></span>
            </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">






    
        
        
        
    




    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/about.jpg" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title"></div>
            <div></div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                



    


<div class="content-root">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="content">
            <div class="content-self">
                <h1 id="任东卫">任东卫</h1>
<p>手机号 : 15063080813</p>
<p>邮箱 : <a href="mailto:86930007@qq.com">86930007@qq.com</a></p>
<p>github : <a href="http://github.com/rendongwei">http://github.com/rendongwei</a></p>
<p>gitee : <a href="https://gitee.com/rendongwei">don. (rendongwei) - Gitee.com</a></p>
<p>工作年限 : 11年</p>
<h2 id="教育背景">教育背景</h2>
<p>2009-2011	青岛职业技术学院    计算机应用技术</p>
<h2 id="专业技能">专业技能</h2>
<ol>
<li>熟练使用MVVM 架构和<code>Glide</code>、<code>Retrofit</code>、<code>OkHttp</code>、<code>Gson</code>、<code>GreenDao</code> 等开源库。</li>
<li>熟练使用Kotlin 语言，熟练使用<code>Kotlin Coroutines</code>、<code>lambda</code>、<code>lazy</code>、<code>Extend</code> 等Kotlin 新特性。</li>
<li>熟练使用Google 官方指定架构Jetpack 下的基于Android KTX 的<code>LiveData</code>、<code>Coil</code>、<code>Room</code>、<code>Lifecycles</code> 等开源库。</li>
</ol>
<h2 id="自我评价">自我评价</h2>
<ol>
<li>工作认真负责，积极主动，能吃苦耐劳。</li>
<li>较强的适应能力和自学能力，较强的管理、组织能力。</li>
<li>思维敏捷，较强的动手实践能力和团体协作精神。</li>
<li>喜欢创新、热爱钻研，喜欢研究前沿技术。</li>
</ol>
<h2 id="工作经历">工作经历</h2>
<ul>
<li>
<p>青岛小二哥科技有限公司</p>
<ul>
<li>2021.03 - 2022.04</li>
</ul>
</li>
<li>
<p>即刻回音(北京)科技信息技术有限公司</p>
<ul>
<li>2020.04 - 2021.02</li>
</ul>
</li>
<li>
<p>青岛启程儿童机器人有限公司</p>
<ul>
<li>2017.10 - 2020.01</li>
</ul>
</li>
<li>
<p>青岛华夏车汇网络技术有限公司</p>
<ul>
<li>2016.06 - 2017.10</li>
</ul>
</li>
<li>
<p>青岛中劳网信息技术有限公司</p>
<ul>
<li>2014.09 - 2016.05</li>
</ul>
</li>
<li>
<p>青岛英网资讯股份有限公司</p>
<ul>
<li>2014.02 - 2014.09</li>
</ul>
</li>
<li>
<p>青岛网星云软件服务有限公司</p>
<ul>
<li>2012.05 - 2014.02</li>
</ul>
</li>
</ul>

            </div>
            
        </div>
        
    
</div>

    


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            <div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/avatar.jpg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">Don</div>
            <div class="jianjie">
                Android Development Engineer
            </div>
        </div>
    </div>

    <div class="type">
        <a href='/posts' class="wenzhang">
            <p>
                
                    
                
            </p>
            <p>6</p>
        </a>
        <a href='/categories' class="fenlei">
            <p></p>
            <p>2</p>
        </a>
        <a href='/tags' class="biaoqian">
            <p></p>
            <p>3</p>
        </a>
    </div>

    <a href="https://github.com/rendongwei">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd"></div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd"></div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="http://rendongwei.cn/posts/kotlin-sealed/" class="">
                
<a href="http://rendongwei.cn/posts/kotlin-sealed/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/start.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Kotlin-Sealed密封类
            </div>
            <div class="other-summary">在代码中，我们经常需要限定一些有限集合的状态值，例如： 网络请求：成功——失败 账户状态：VIP——穷逼</div>
            <div class="other-date">2022-11-8</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://rendongwei.cn/posts/android-disklrucache/" class="">
                
<a href="http://rendongwei.cn/posts/android-disklrucache/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/start.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Android-DiskLruCache
            </div>
            <div class="other-summary">什么是DiskLruCache 是文件缓存的管理对象，使用 LRU 算法对保存在永久存储设备上的缓存文件进行管</div>
            <div class="other-date">2022-11-7</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://rendongwei.cn/posts/android-gson/" class="">
                
<a href="http://rendongwei.cn/posts/android-gson/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/start.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Android-Gson
            </div>
            <div class="other-summary">什么是Gson Gson 是一个Java库，可用于将Java对象转换为它们的Json 表示形式。它还可以用于将J</div>
            <div class="other-date">2022-11-7</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://rendongwei.cn/posts/android-room/" class="">
                
<a href="http://rendongwei.cn/posts/android-room/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/start.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Android-Room
            </div>
            <div class="other-summary">前言 room是官方推出的数据库映射框架。在没有room之前，比较出名的就是greendao库。既然官</div>
            <div class="other-date">2022-11-7</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://rendongwei.cn/posts/android-glide/" class="">
                
<a href="http://rendongwei.cn/posts/android-glide/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/start.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Android-Glide
            </div>
            <div class="other-summary">前言 Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。统一了显示本地图片和网络图</div>
            <div class="other-date">2022-11-4</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                
                    <div class="footer-item">
                        © 2022-2022 <a href="https://github.com/rendongwei">Don</a>
                    </div>
                
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button></button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        




    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var postsCount =  6 ;
    var arrPosts = [{"link":"http://rendongwei.cn/posts/kotlin-sealed/","plain":"在代码中，我们经常需要限定一些有限集合的状态值，例如：\n网络请求：成功——失败 账户状态：VIP——穷逼VIP——普通 工具栏：展开——半折叠——收缩 等等。\n通常情况下，我们会使用enum class来做封装，将可见的状态值通过枚举来使用。\n1 2 3 4 enum class NetworkState(val value: Int) { SUCCESS(0), ERROR(1) } 但枚举的缺点也很明显，首先，枚举比普通代码更占内存，同时，每个枚举只能定义一个实例，不能拓展更多信息。\n除此之外，还有种方式，通过抽象类来对状态进行封装，但这种方式的缺点也很明显，它打破了枚举的限制性，所以，Kotlin给出了新的解决方案——Sealed Class（密封类）。\n一、创建状态集 下面我们以网络请求的例子来看下具体如何使用Sealed Class来进行状态的封装。\n和抽象类类似，Sealed Class可用于表示层级关系。它的子类可以是任意的类：data class、普通Kotlin对象、普通的类，甚至也可以是另一个密封类，所以，我们定义一个Result Sealed Class：\n1 2 3 4 sealed class Result\u0026lt;out T : Any\u0026gt; { data class Success\u0026lt;out T : Any\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val exception: Exception) : Result\u0026lt;Nothing\u0026gt;() } 当然，也不一定非要写在顶层类中：\n1 2 3 sealed class Result\u0026lt;out T : Any\u0026gt; data class Success\u0026lt;out T : Any\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val exception: Exception) : Result\u0026lt;Nothing\u0026gt;() 这样也是可以的，它们的区别在于引用的时候，是否包含顶层类来引用而已。\n大部分场景下，还是建议第一种方式，可以比较清晰的展示调用的层级关系。\n在这个例子中，我们定义了两个场景，分别是Success和Error，它表示我们假设的网络状态就这两种，分别在每种状态下，例如Success，都可以传入自定义的数据类型，因为它本身就是一个class，所以借助这一点，就可以自定义状态携带的场景值。在上面这个例子中，我们定义在Success中，传递data，而在Error时，传递Exception信息。\n所以，使用Sealed Class的第一步，就是对场景进行封装，梳理具体的场景枚举，并定义需要传递的数据类型。\n如果场景值不需要传递数据，那么可以简单的使用：object xxxx，定义一个变量即可。\n二、使用 接下来，我们来看下如何使用Sealed Class。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fun main() { // 模拟封装枚举的产生 val result = if (true) { Result.Success(\u0026#34;Success\u0026#34;) } else { Result.Error(Exception(\u0026#34;error\u0026#34;)) } when (result) { is Result.Success -\u0026gt; print(result.data) is Result.Error -\u0026gt; print(result.exception) } } 大部分场景下，Sealed Class都会配合when一起使用，同时，如果when的参数是Sealed Class，在IDE中可以快速补全所有分支，而且不会需要你单独补充else 分支，因为Sealed Class已经是完备的了。\n所以when和Sealed Class真是天作之合。\n三、进一步简化 其实我们还可以进一步简化代码的调用，因为我们每次使用Sealed Class的时候，都需要when一下，有些时候，也会产生一些代码冗余，所以，借助拓展函数，我们进一步对代码进行简化。\n1 2 3 4 5 6 7 8 9 10 11 inline fun Result\u0026lt;Any\u0026gt;.doSuccess(success: (Any) -\u0026gt; Unit) { if (this is Result.Success) { success(data) } } inline fun Result\u0026lt;Any\u0026gt;.doError(error: (Exception?) -\u0026gt; Unit) { if (this is Result.Error) { error(exception) } } 这里我对Result进行了拓展，增加了doSuccess和doError两个拓展，同时接收两个高阶函数来接收处理行为，这样我们在调用的时候就更加简单了。\n1 2 result.doSuccess { } result.doError { } 所以when和Sealed Class和拓展函数，真是天作之合。\n那么你一定好奇了，Sealed Class又是怎么实现的，其实反编译一下就一目了然了，实际上Sealed Class也是通过抽象类来实现的，编译器生成了一个只能编译器调用的构造函数，从而避免其它类进行修改，实现了Sealed Class的有限性。\n四、封装 Sealed Class与抽象类类似，可以对逻辑进行拓展，我们来看下面这个例子。\n1 2 3 4 5 6 7 8 9 10 11 12 sealed class TTS { abstract fun speak() class BaiduTTS(val value: String) : TTS() { override fun speak() = print(value) } class TencentTTS(val value: String) : TTS() { override fun speak() = print(value) } } 这时候如果要进行拓展，就很方便了，代码如下所示。\n1 2 3 class XunFeiTTS(val value: String) : TTS() { override fun speak() = print(value) } 所以，Sealed Class可以说是在抽象类的基础上，增加了对状态有限性的控制，拓展与抽象，比枚举更加灵活和方便了。\n再例如前面网络的封装：\n1 2 3 4 5 6 7 8 9 sealed class Result\u0026lt;out T : Any\u0026gt; { data class Success\u0026lt;out T : Any\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() sealed class Error(val exception: Exception) : Result\u0026lt;Nothing\u0026gt;() { class RecoverableError(exception: Exception) : Error(exception) class NonRecoverableError(exception: Exception) : Error(exception) } object InProgress : Result\u0026lt;Nothing\u0026gt;() } 通过Sealed Class可以很方便的对Error类型进行拓展，同时，增加新的状态也非常简单，更重要的是，通过IDE的自动补全功能，IDE可以自动生成各个条件分支，避免人工编码的遗漏。\n","pubDate":"2022-11-08","title":"Kotlin-Sealed密封类"},{"link":"http://rendongwei.cn/posts/android-disklrucache/","plain":"什么是DiskLruCache 是文件缓存的管理对象，使用 LRU 算法对保存在永久存储设备上的缓存文件进行管理。\n比手机的闪存更低速的访问设备是网络，文件缓存的意义就在于通过重复利用缓存的数据，减少网络请求构造方法是 private 修饰的，无法使用。，减少网络流量，提高响应速度。\n用法 使用静态方法 static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) 来创建 DiskLruCache 对象。 构造方法是 private 修饰的，无法使用。 参数 directory 表示保存的目录，注意外部目录权限问题。 参数 appVersion 可以设置为版本号 version code。 参数 valueCount 表示一个 key 可以关联几个文件，一般为 1（一般情况关联多个没有必要，而且会增加编码复杂度）。 参数 maxSize 缓存大小限制，单位 Byte。 需要调用 close() 关闭。 读取缓存 先调用 DiskLruCache.Snapshot get(String key) 获取一个 DiskLruCache.Snapshot 对象，再通过这个对象进行读取操作。 返回的类型是 DiskLruCache.Snapshot，其实就是这个 key 对应的相关数据，主要是多个文件的输入流和大小，多个文件的数量对应构造方法里的 valueCount。 Snapshot.getLength(int index) 获取文件大小，进行一些判断。 Snapshot.getInputStream(int index) 获取一个 InputStream，可以用来读取文件内容，注意这个流不是缓存流，如果需要缓存流可以创建 BufferedInputStream 包装一下 InputStream。 这个 InputStream 需要手动关闭，既可以直接关闭 InputStream，也可以调用 Snapshot.close() 来关闭属于它的所有 InputStream。 写入缓存 先调用 DiskLruCache.Editor edit(String key) 方法获取一个 DiskLruCache.Editor 对象，再通过这个对象进行写入操作。 返回的类型是 DiskLruCache.Editor，其实就是将写入相关的一些操作抽象处理，对这个对象的操作都对应 key 关联的缓存文件。 如果同时有另一个 Editor 对象是通过 key 获取的，edit 方法将返回 null。保证同时只有一个 Editor 对象在对同一个 key 进行写入操作。因此调用之后需要判断一下。 OutputStream newOutputStream(int index) 创建输出流来写入数据，注意这个流不是缓存流，如果需要缓存流可以创建 BufferedOutputStream 包装一下 OutputStream。 这个 OutputStream 需要手动关闭。 除了关闭输出流，还还需对 Editor 设置结果。如果写入操作和相关业务成功了，缓存文件有效，则调用 Editor.commit() 方法表示缓存写入成功。如果写入操作或相关业务失败了，缓存文件无效，则调用 Editor.abort() 来还原为未获取 Editor 之前的状态。 线程安全和一致性 DiskLruCache 管理多个 Entry（key-values），因此锁粒度应该是 Entry 级别的。\nget 和 edit 方法都是同步方法，保证内部的 Entry Map 的安全访问，是保证线程安全的第一步。\nget 和 edit 方法都返回一个对象来关联某个 Entry\n对读取来说，允许多个对象同时读取，不需要加锁 对写入来说，edit 方法内部保证不会有两个 Editor 同时关联一个 Entry。直接利用方法本身的锁就达到了目的。 可以同时读写一个 Entry，读和写不互相影响，读的是快照，写是原子操作。\n读取方法 get 返回后，就像返回值类型 Snapshot 的词义暗示的那样，它是一个快照对象，再对这个 Entry 进行任何操作都不会影响快照对象，快照对象在返回的时候就固定了，关联的输入流也一样。 完成一次写入必须调用 commit 方法，commit 方法是原子操作，多个 value 的修改要么同时不可见，要么同时可见。 注意 缓存空间的大小限制并不是特别精确，体现在并不一定及时删除应该删除的缓存文件，大小的计算也不包括内部文件以及文件系统的额外消耗。对空间敏感的使用者应该设置一个保守的大小。 open 方法的 appVersion 其实不必是应用的 version code。因为 appVersion 属性的主要作用是在升级app后清空缓存文件。DiskLruCache 这样做的原因是假定 app 的升级会导致缓存数据与新代码不兼容，可以说这是一种保守的策略。如果你能分辨出是否有不兼容问题，那么就可以随意定制 appVersion 这个参数，减少不必要的全局删除。如果不可能出现不兼容问题，那么就直接设置为一个固定值就可以了。 key 必须 match 正则表达式 [a-z0-9_-]{1,64}，在实际使用中，可以用 md5 的方法将 url 转换为符合条件的字符串。 缓存目录必须只能用于 DiskLruCache 缓存，不能再用作别的目的，因为 DiskLruCache 可能会删除或覆盖其中的文件。 不要多进程使用同一个缓存目录，可能会发生错误。 实现原理 DiskLruCache 内部使用一个 journal 文件来记录和管理缓存文件。文件内容大概长这样：\nlibcore.io.DiskLruCache\r1\r100\r2\rCLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054\rDIRTY 335c4c6028171cfddfbaae1a9c313c52\rCLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342\rREMOVE 335c4c6028171cfddfbaae1a9c313c52\rDIRTY 1ab96a171faeeee38496d8b330771a7a\rCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234\rREAD 335c4c6028171cfddfbaae1a9c313c52\rREAD 3400330d1dfc7f3f7f4b8d4d803dfcf6 journal 文件记录了一些元信息，比如版本号什么的。\njournal 文件还记录了每个 Entry 的数据，有四种状态：\nDIRTY：表示正在写入 CLEAN：表示就绪，可以读取到最新的修改了 REMOVE：表示被删除了 READ：表示正在读取 Entry 数据并不是在记录的位置“原地”修改，而是不停地添加新的状态到文件末尾，只有读取到最新的一条 Entry 相关的记录才能知道它的最新状态。随着操作越来越多，DiskLruCache 也会执行压缩，删除之前的状态。\n","pubDate":"2022-11-07","title":"Android-DiskLruCache"},{"link":"http://rendongwei.cn/posts/android-gson/","plain":"什么是Gson Gson 是一个Java库，可用于将Java对象转换为它们的Json 表示形式。它还可以用于将Json 字符串转换为等效的Java对象。Json 的解析和生成的方式很多，在 Android 平台上最常用的类库有 Gson 和 FastJson 两种，这里要介绍的是 Gson。\nGson 的 GitHub主页点击这里：Gson\n如何下载 Gradle:\n1 2 3 dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.9\u0026#39; } Json的生成 1 Gson().toJson(any) Json的解析 类 1 val user : User = Gson().fromJson(json,User::class) 复杂类型 1 val map : Map\u0026lt;String , Any\u0026gt; = Gson().fromJson(json,object : TypeToken\u0026lt;Map\u0026lt;String , Any\u0026gt;\u0026gt;() {}.type) Json的注解 1.自定义字段的名字 1 2 @SerializedName(\u0026#34;w\u0026#34;) var width:Int? = null 这个注解可以用来自定义序列化和反序列化过程中字段的名字。 以上面为例，当序列化的时候，会把Java bean中的字段width存储成w，在反序列化的时候会把Json的w这个key反序列化到Java bean的width字段上。\n2.定义那些字段需要被序列化或者反序列化 注意，在Java中，所有用transient声明的字段，都不会被Gson序列化和反序列化\nGson提供了注解来分别的控制某一个字段是否需要被序列化或者反序列化。对序列化和反序列化分开控制。\n使用@Expose注解，我们可以对序列化和反序列化单独控制，该注解有两个值，分别是deserialize和serialize，比如如下的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Account { // 声明该字段不参与反序列化 @Expose(deserialize = false) var accountNumber : String? = null // 只要有一个字段使用了Expose注解，所有需要参与序列化和反序列化的字段都要有这个注解 // 因为这个注解要么不生效，如果生效的话，就只会对有Expose注解的字段进行处理。 @Expose var iban : String? = null // 声明该字段不参与序列化 @Expose(serialize = false) var owner : String? = null // 声明该字段序列化和反序列化都不参与 @Expose(serialize = false, deserialize = false) var address : String? = null var pin : String? = null } 要使该注解生效，必须对Gson进行配置，如下\n1 2 3 val builder : GsonBuilder = GsonBuilder() builder.excludeFieldsWithoutExposeAnnotation() val gson : Gson = builder.create() 如果我们不对Gson进行配置的话，该注解就不会生效，这样就会默认所有的字段都会被序列化和反序列化。\n通过对Gson进行配置，只有带有Expose注解的字段才会被Gson进行序列化或者反序列化。\n3.对Java Bean进行版本控制，这个使用的很少，比如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SoccerPlayer { var name : String? = null //表明这个属性是1.2版本之后才加入的 @Since(1.2) var shirtNumber : Int? = null //表明这个属性是在0.9版本上已经被移出了 @Until(0.9) var country : String? = null var teamName : String? = null } 和Expose一样，要使用这两个注解，也需要对Gson进行配置，如下\n1 2 3 4 5 val builder : GsonBuilder = GsonBuilder() //在这里，我们定义版本是1.0，由于shirtNumber在1.2才加入，所以不生效 //country在0.9被移除，所以也不生效 builder.setVersion(1.0) val gson : Gson = builder.create() ","pubDate":"2022-11-07","title":"Android-Gson"},{"link":"http://rendongwei.cn/posts/android-room/","plain":"前言 room是官方推出的数据库映射框架。在没有room之前，比较出名的就是greendao库。既然官方都出了，还是用官方的吧。 使用room或者然后第三方框架，最好使用android 4.2以及之后的版本。因为这些新版本支持Database Inspector功能。也就是直接查看数据库的功能，以前的版本只能导出查看非常的麻烦。\n可以通过View-\u0026gt;Tool Window-\u0026gt;Database Inspector打开这个功能。 在一些新版本中，这个功能被移动到App Inspection里面。 同时需要SDK26及以上版本。\n一、添加依赖 1 2 3 4 5 6 7 8 def room_version=\u0026#34;2.4.2\u0026#34; implementation \u0026#34;androidx.room:room-runtime:$room_version\u0026#34; annotationProcessor \u0026#34;androidx.room:room-compiler:$room_version\u0026#34; //implementation \u0026#34;androidx.room:room-rxjava2:$room_version\u0026#34; //implementation \u0026#34;androidx.room:room-rxjava3:$room_version\u0026#34; //implementation \u0026#34;androidx.room:room-guava:$room_version\u0026#34; //testImplementation \u0026#34;androidx.room:room-testing:$room_version\u0026#34; //implementation \u0026#34;androidx.room:room-paging:2.5.0-alpha01\u0026#34; 二、创建数据库 1. 创建映射实体类 创建实体类，这个实体类就是数据库映射的接受类，对应的是数据库的user表，可以将数据库的表结构映射成Bean。使用注解标记相应的功能，通过名字就可以非常清楚的知道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 表结构实体 @Entity class User { // 主键 @PrimaryKey var uid : Int? = null // 列/字段信息 @ColumnInfo(name = \u0026#34;first_name\u0026#34;) var firstName : String? = null // 列/字段信息 @ColumnInfo(name = \u0026#34;last_name\u0026#34;) var lastName : String? = null } 2.创建Dao接口 创建我们的Dao接口，这种实现方式和Retrofit是非常相似的。其实最感觉的就是SQL语句。这里我们先只关系getAll这个方法就行，语句是最简单的SELECT * FROM user。 对应的注解也是非常容易理解,分别对应增删改查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 interface UserDao { // 查询 @Query(\u0026#34;SELECT * FROM user\u0026#34;) fun getAll() : MutableList\u0026lt;User\u0026gt; // 条件查询 @Query(\u0026#34;SELECT * FROM user WHERE uid IN (:userIds)\u0026#34;) fun getUserByIds(userIds : IntArray) : MutableList\u0026lt;User\u0026gt; // 条件查询 @Query(\u0026#34;SELECT * FROM user WHERE first_name LIKE :first AND last_name LIKE :last LIMIT 1\u0026#34;) fun getUserByName(first : String , last : String) : User // 插入 @Insert fun insertAll(vararg users : User) // 删除 @DELETE fun delete(user : User) } 3.创建数据库抽象接口 需要继承RoomDatabase，通过@Database指定需要创建的表。还可以指定版本。\n1 2 3 4 @Database(entities = {User::class} , version = 1) abstract class AppDatabase : RoomDatabase { abstract fun userDao() : UserDao } 我们发现这个我们自己定义的AppDatabase还是抽象类，因为她的实现需要移除在Activity或者Fragment里面实现。通过下面的代码创建真正的实现类。到这一步，数据库，表和UserDao都已经创建好了，通过AppDatabase的userDao方法，我们就可以获取到UserDao的实现。然后就可以直接调用对应的方法实现增删改查。\n1 val db : AppDatabase = Room.databaseBuilder(applicationContext,AppDatabase::class,\u0026#34;app.db\u0026#34;).build() 下面是完整的测试代码，我们需要创建一个协程。我们插入两条数据到user表中。\n1 2 3 4 5 6 7 8 9 GlobalScope.launch { val db : AppDatabase = Room.databaseBuilder(applicationContext,AppDatabase::class,\u0026#34;app.db\u0026#34;).build() val userDao = db.userDao() val user = User(1,\u0026#34;Tom\u0026#34;,\u0026#34;Cat\u0026#34;) val user1 = User(2,\u0026#34;Tom\u0026#34;,\u0026#34;Cruise\u0026#34;) userDao.insertAll(user,user1) val users : MutableList\u0026lt;User\u0026gt; = userDao.getAll() Log.d(\u0026#34;tag\u0026#34;,\u0026#34;users : $users\u0026#34;) } 三、Room的增删改查实现和细节 在数据库操作中其实最重要的是SQL语句，别的操作反而是次要的。\n1.插入操作 使用@Insert注解声明的Dao接口方法。\n下面的代码分别可以插入一个和插入多条数据，只需要传入相应的User对象。这种方式是最常用的。\n1 2 3 4 5 @Insert fun insert(user : User) @Insert fun insertAll(vararg users : User) 这种方式是典型的数据库映射，也是room的这种ORM的精髓。\n2.删除操作 和插入操作类似。可以删除一条数据或者根据条件删除多条数据。\n1 2 3 4 5 @DELETE fun delete(user : User) @Query(\u0026#34;DELETE FROM user WHERE uid \u0026gt; 0\u0026#34;) fun deleteAll() 3.查询操作 查询专门指SELECT语句，而不是@Query注解，这个注解可以做很多事情，前面我们看到，这个注解就是用来执行SQL语句的。\n1 2 @Query fun getAll() : MutableList\u0026lt;User\u0026gt; 4.更新操作 可以通过room提供的@Update注解来实现，当然也可以通过@Query直接执行SQL语句。\n1 2 3 4 5 @Update fun update(user : User) @Query(\u0026#34;UPDATE user SET last_name = :lastName WHERE first_name = :firstName\u0026#34;) fun updateOne(firstName : String , lastName : String) ","pubDate":"2022-11-07","title":"Android-Room"},{"link":"http://rendongwei.cn/posts/android-glide/","plain":"前言 Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。统一了显示本地图片和网络图片的接口。\n使用步骤 1.添加Glide库的依赖： 1 2 3 implementation \u0026#39;com.github.bumptech.glide:glide:4.9.0\u0026#39; annotationProcessor \u0026#39;com.github.bumptech.glide:compiler:4.9.0\u0026#39; annotationProcessor \u0026#39;androidx.annotation:annotation:1.1.0\u0026#39; 2.添加权限 1 2 3 4 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; 3.初步使用 1 2 3 4 val url = \u0026#34;http://host/image.png\u0026#34; Glide.with(context) .load(url) .into(imageView) 4.转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val options = RequestOptions() // 变换显示样式 .centerCrop() // 请求时占位 .placeholder(R.mipmap.loading) // 请求失败 .error(R.mipmap.error) // 请求为空的时候 .fallback(R.mipmap.empty) val url = \u0026#34;http://host/image.png\u0026#34; Glide.with(context) .load(url) .apply(options) .into(imageView) 5.缓存 默认情况下，Glide会再开始一个新的图片请求之前检查以下多级的缓存:\n活动资源(Active Resources) : 现在是否有另一个View正在展示这张图片 内存缓存(Memory Cache) : 该图片是否最近被加载过并仍存在于内存 资源类型(Resources) : 该图片是否之前曾被解码、转换并写入过磁盘缓存 数据来源(Data) : 构建这个图片的资源是否之前有被写入过文件缓存 内存缓存 通过skipMemoryCache(true)可以设置不进行内存缓存\n磁盘缓存 通过diskCacheStrategy(DiskCacheStrategy)设置缓存策略\n磁盘缓存策略 DiskCacheStrategy.ALL 既缓存原图又缓存处理图 DiskCacheStrategy.NONE 什么都不缓存 DiskCacheStrategy.SOURCE 只缓存原图 DiskCacheStrategy.RESULT 只缓存处理图 清除内存缓存 1 Glide.with(context).clearMemory() 清除磁盘缓存\n1 2 3 GlobalScope.launch { Glide.with(context).clearDiskCache() } 清除磁盘缓存需要子线程运行\n使用缩略图 1 2 3 4 5 6 val url = \u0026#34;http://host/image.png\u0026#34; Glide.with(context) .load(url) // 缩略图大小未原来的1/10 .thumbnail(0.1f) .into(imageView) 使用Target 1 2 3 4 5 6 7 8 9 val url = \u0026#34;http://host/image.png\u0026#34; val target = object : SimpleTarget\u0026lt;Bitmap\u0026gt;() { override fun onResourceReady(resource: Bitmap, transition :Transition\u0026lt;in Bitmap\u0026gt;?) { imageview.setImageBitmap(resource) } } Glide.with(context) .load(url) .into(target) ","pubDate":"2022-11-04","title":"Android-Glide"},{"link":"http://rendongwei.cn/posts/android-retrofit/","plain":"前言 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装\n使用步骤 1.添加Retrofit库的依赖： 1 2 3 4 implementation \u0026#39;com.squareup.retrofit2:retrofit:2.0.2\u0026#39; implementation \u0026#39;com.squareup.retrofit2:converter-gson:2.0.2\u0026#39; implementation \u0026#39;com.google.code.gson:gson:2.8.5\u0026#39; implementation \u0026#39;com.squareup.retrofit2:adapter-rxjava:2.0.2\u0026#39; 后面三个是可选的，分别是数据解析器和gson，以及rxjava支持的依赖\n2.创建用于描述网络请求的接口 Retrofit将 Http请求 抽象成 kotlin接口：采用 注解 描述网络请求参数 和配置网络请求参数\n1 2 3 4 interface ApiSerivce{ @GET(\u0026#34;/api/call\u0026#34;) fun getCall(@Query(\u0026#34;name\u0026#34;) name : String) : Call\u0026lt;String\u0026gt; } 3.创建Retrofit实例 1 2 3 4 5 val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;http://api.xxx.com\u0026#34;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build() 4.发送请求 请求分为同步请求和异步请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 val service = retrofit.create(ApiService::class) val call = service.getCall(\u0026#34;张**\u0026#34;) // 同步请求 try{ val response : Response\u0026lt;String\u0026gt; = call.execute() val reuslt = response.body() }catch(e:Exception){ } // 异步请求 call.enqueue(object : CallBack\u0026lt;String\u0026gt;{ @Override fun onResponse(call : Call\u0026lt;String\u0026gt; , response : Response\u0026lt;String\u0026gt;){ val reuslt = response.body() } fun onError(call : Call\u0026lt;String\u0026gt; , throwable : Throwable){ } }) response.body()就是Reception对象，网络请求的完整 Url =在创建Retrofit实例时通过.baseUrl()设置 +网络请求接口的注解设置（下面称 “path“ ） 整合的规则如下：\n类型 具体使用 path = 完整的Url Url = \u0026ldquo;http://host:port/api/login\u0026rdquo; path = \u0026ldquo;http://host:port/api/login\u0026rdquo;\nbaseUrl = 不设置 path = 绝对路径 Url = \u0026ldquo;http://host:port/api/login\u0026rdquo;\npath = \u0026ldquo;/login\u0026rdquo;\nbaseUrl = \u0026ldquo;http://host:port/api/\u0026rdquo; path = 相对路径\nbaseUrl = 目录形式 Url = \u0026ldquo;http://host:port/api/v1/login\u0026rdquo; path = \u0026ldquo;login\u0026rdquo;\nbaseUrl = \u0026ldquo;http://host:port/api/v1\u0026rdquo; path = 相对路径\nbaseUrl = 文件形式 Url = \u0026ldquo;http://host:port/api/v1/login\u0026rdquo; path = \u0026ldquo;login\u0026rdquo;\nbaseUrl = \u0026ldquo;http://host:port/api/v1\u0026rdquo; 注解 上面我们用了@GET注解来发送Get请求，Retrofit还提供了很多其他的注解类型\n网络请求方法 @GET 、 @POST 、 @PUT 、@DELETE 、@PATH 、@HEAD 、@OPTIONS 、@HTTP\n标记类 @FormUrlEncoded 、@Multipart 、@Streaming\n网络请求参数 @Header 、@headers 、@URL 、@Body 、@Path 、@Field 、@FieldMap 、@Part 、@PartMap 、@Query 、@QueryMap\n第一类 : 网络请求方法 @GET、@POST、@PUT、@DELETE、@HEAD分别对应 HTTP中的网络请求方式\n@HTTP替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展\n具体使用：通过属性method、path、hasBody进行设置\n1 2 3 4 5 6 7 8 9 interface ApiService{ /** * method : 网络请求方法(区分大小写) * path : 网络请求地址路径 * hasBody : 是否有请求体 */ @HTTP(method = \u0026#34;GET\u0026#34; , path = \u0026#34;blog/{id}\u0026#34; , hasBody = false) fun getCall(@Path(\u0026#34;id\u0026#34;) id : String) : Call\u0026lt;String\u0026gt; } 第二类 : 标记 @FormUrlEncoded\n表示发送form-encoded的数据，每个键值对需要用@Filed来注解键名，随后的对象需要提供值。\n@Multipart\n表示发送 form-encoded 的数据（适用于 有文件 上传的场景），每个键值对需要用@Part来注解键名，随后的对象需要提供值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface ApiService{ /** * 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded） * \u0026lt;code\u0026gt;Field(\u0026#34;name\u0026#34;)\u0026lt;/code\u0026gt; 表示将后面的 \u0026lt;code\u0026gt;String name\u0026lt;/code\u0026gt; */ @POST(\u0026#34;/form\u0026#34;) @FormUrlEncoded fun test(@Field(\u0026#34;name\u0026#34;) name : String) : Call\u0026lt;String\u0026gt; /** * Part后面支持三种类型，RequestBody、MultipartBody.Part 、任意类型 * 除 MultipartBody.Part以外，其它类型都必须带上表单字段 (MultipartBody.Part 中已经包含了表单字段的信息) */ @POST(\u0026#34;/form\u0026#34;) @Multpart fun test(@Part(\u0026#34;name\u0026#34;) name : RequestBody) : Call\u0026lt;String\u0026gt; } 第三类 : 网络请求参数 注解名称 解释 @Headers 添加请求头 @Header 添加不固定值的Header @Body 用于非表单请求体 @Field 向Post表单传入键值对 @FieldMap 向Post表单传入键值对 @Part 用于表单字段，适用于有文件上传的情况 @PartMap 用于表单字段，适用于有文件上传的情况 @Query 用于表单字段，功能同@Field@FieldMap,区别是一个体现在URL上，一个在请求体上 @QueryMap 用于表单字段，功能同@Field@FieldMap,区别是一个体现在URL上，一个在请求体上 @Path URL缺省值 @URL URL设置 1.@Header \u0026amp; @Headers 添加请求头 \u0026amp;添加不固定的请求头\n1 2 3 4 5 6 7 8 // @Header @GET(\u0026#34;/user\u0026#34;) fun getUser(@Header(\u0026#34;Authorization\u0026#34;) authorization : String) : Call\u0026lt;User\u0026gt; // @Headers @GET(\u0026#34;/user\u0026#34;) @Headers(\u0026#34;Authorization : authorization\u0026#34;) fun getUser() : Call\u0026lt;User\u0026gt; 以上的效果是一致的\n区别在于使用场景和使用方式\n使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头 使用方式：@Header作用于方法的参数；@Headers作用于方法 2.@Body 以 Post方式 传递 自定义数据类型 给服务器,如果提交的是一个Map，那么作用相当于 @Field,不过Map要经过 FormBody.Builder 类处理成为符合 OkHttp格式的表单，如：\n1 2 3 4 5 6 7 8 // @Body @POST(\u0026#34;/addUser\u0026#34;) fun addUser(@Body body : FormBody) : Call\u0026lt;String\u0026gt; // body val builder = FormBody.Builder() builder.add(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;) val body = builder.build() 3.@Field \u0026amp; @FieldMap 发送 Post请求 时提交请求的表单字段,与 @FormUrlEncoded 注解配合使用\n1 2 3 4 5 6 7 8 9 // @Field @POST(\u0026#34;/addUser\u0026#34;) @FormUrlEncoded fun addUser(@Field(\u0026#34;name\u0026#34;) name : String , @Field(\u0026#34;age\u0026#34;) age : int) : Call\u0026lt;String\u0026gt; // @FieldMap @POST(\u0026#34;/addUser\u0026#34;) @FormUrlEncoded fun addUser(@FieldMap map : Map\u0026lt;String , Any?\u0026gt;) : Call\u0026lt;String\u0026gt; 4.@Part \u0026amp; @PartMap 发送 Post请求 时提交请求的表单字段,与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景,与 @Multipart 注解配合使用\n1 2 3 4 5 6 7 8 9 // @Part @POST(\u0026#34;/form\u0026#34;) @Multipart fun uploadFile(@Part(\u0026#34;name\u0026#34;) name : RequestBody , @Part file : MultipartBody.Part) : Call\u0026lt;String\u0026gt; // @PartMap @POST(\u0026#34;/form\u0026#34;) @Multipart fun uploadFile(@PartMap map : Map\u0026lt;String , RequestBody?\u0026gt; , @Part file : MultipartBody.Part) : Call\u0026lt;String\u0026gt; 5.@Query \u0026amp; QueryMap 用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）\n1 2 3 4 5 6 7 // @Query @GET(\u0026#34;/getUser\u0026#34;) fun getUser(@Query(\u0026#34;id\u0026#34;) id : String) : Call\u0026lt;User\u0026gt; // @QueryMap @GET(\u0026#34;/getUser\u0026#34;) fun getUser(@QueryMap map : Map\u0026lt;String , Any?\u0026gt;) : Call\u0026lt;User\u0026gt; 6.@Path URL地址的缺省值\n1 2 @GET(\u0026#34;/user/info/{id}\u0026#34;) fun getUser(@Path(\u0026#34;id\u0026#34;) id : String) : Call\u0026lt;User\u0026gt; 7.Url 直接传入一个请求的 URL变量 用于URL设置\n1 2 @GET fun getUser(@Url url : String , @Query(\u0026#34;id\u0026#34;) id : String) : Call\u0026lt;User\u0026gt; ","pubDate":"2022-11-02","title":"Android-Retrofit"}];
</script>





    </body>
</html>

